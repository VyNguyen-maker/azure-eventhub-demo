const { EventHubProducerClient } = require("@azure/event-hubs");
const connectionString = "EVENTHUBCONNECTIONSTRING";
const eventHubName = "EVENTHUBNAME";

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function sample(arr) {
  return arr[randInt(0, arr.length - 1)];
}

// Simple UUID v4 generator (no dependency)
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Generate a random timestamp within last N days
function randomTimestampWithinDays(days) {
  const now = Date.now();
  const past = now - randInt(0, days * 24 * 60 * 60 * 1000);
  return new Date(past).toISOString();
}

// Sample data catalogs (you can mở rộng)
const categories = ["Electronics", "Home", "Beauty", "Fashion", "Toys", "Grocery"];
const suppliers = [
  { supplierId: "SUP-1", name: "Alpha Supplies" },
  { supplierId: "SUP-2", name: "Beta Trading" },
  { supplierId: "SUP-3", name: "Gamma Goods" },
  { supplierId: "SUP-4", name: "Delta Wholesale" }
];
const shippingProviders = ["FastShip", "GoDeliver", "LocalPost", "ExpressNow"];
const warehouses = ["WH-1", "WH-2", "WH-3"];
const channels = ["app", "web", "social", "affiliate"];
const cities = [
  { city: "Hanoi", region: "North" },
  { city: "Ho Chi Minh", region: "South" },
  { city: "Da Nang", region: "Central" },
  { city: "Hai Phong", region: "North" },
  { city: "Can Tho", region: "South" }
];
const paymentMethods = ["CreditCard", "COD", "E-Wallet", "BankTransfer"];

// Build product catalog (10 products with supplier linkage)
const products = [];
for (let i = 1; i <= 20; i++) {
  const sup = sample(suppliers);
  products.push({
    productId: `P-${i}`,
    name: `Product ${i}`,
    category: sample(categories),
    supplierId: sup.supplierId,
    price: +(randInt(50, 2000) + Math.random()).toFixed(2)  // price in some currency unit
  });
}

// Simulate users
const users = [];
for (let u = 1; u <= 120; u++) {
  users.push({
    userId: `U-${u}`,
    createdAt: randomTimestampWithinDays(365),
    // some basic segmentation for later analytics
    segment: (u % 10 === 0) ? "VIP" : ((u % 3 === 0) ? "Frequent" : "Normal")
  });
}

async function main() {
  const producer = new EventHubProducerClient(connectionString, eventHubName);

  // Number of orders to generate
  const NUM_ORDERS = 500;

  for (let i = 0; i < NUM_ORDERS; i++) {
    // Create an order with 1-4 items
    const orderId = uuidv4();
    const customer = sample(users);
    const numItems = randInt(1, 4);
    const items = [];

    let orderSubtotal = 0;

    for (let j = 0; j < numItems; j++) {
      const prod = sample(products);
      const qty = randInt(1, 3);
      const unitPrice = prod.price;
      const itemTotal = +(qty * unitPrice).toFixed(2);
      orderSubtotal += itemTotal;

      items.push({
productId: prod.productId,
        name: prod.name,
        category: prod.category,
        supplierId: prod.supplierId,
        unitPrice: unitPrice,
        quantity: qty,
        total: itemTotal
      });
    }

    // Discounts & fees (simple logic)
    const discount = (Math.random() < 0.15) ? +(orderSubtotal * 0.05).toFixed(2) : 0; // 15% orders have 5% discount
    const shippingFee = +( (orderSubtotal > 1000) ? 0 : randInt(15, 50) ).toFixed(2);
    const tax = +(orderSubtotal * 0.08).toFixed(2);
    const grandTotal = +(orderSubtotal - discount + shippingFee + tax).toFixed(2);

    // Processing & shipping times (ms) realistic ranges (in hours -> convert to ISO times)
    const createdAt = randomTimestampWithinDays(90);
    const processingHours = randInt(1, 48); // 1 to 48 hours
    const shippingHours = randInt(6, 168); // 6 hours to 7 days
    const processedAt = new Date(new Date(createdAt).getTime() + processingHours * 3600 * 1000).toISOString();
    const shippedAt = new Date(new Date(processedAt).getTime() + randInt(1, 24) * 3600 * 1000).toISOString();
    const deliveredAt = new Date(new Date(shippedAt).getTime() + shippingHours * 3600 * 1000).toISOString();

    // Random order statuses weighted
    const statusRoll = Math.random();
    let orderStatus = "delivered";
    if (statusRoll < 0.03) orderStatus = "cancelled";
    else if (statusRoll < 0.07) orderStatus = "returned";
    else if (statusRoll < 0.20) orderStatus = "shipped";
    else if (statusRoll < 0.98) orderStatus = "delivered";

    // Include return reason sometimes
    let returnReason = null;
    if (orderStatus === "returned") {
      returnReason = sample(["Damaged", "Wrong item", "Customer changed mind", "Quality not as expected"]);
    }

    // Possibly include a review (only for delivered orders and some probability)
    let review = null;
    if (orderStatus === "delivered" && Math.random() < 0.25) { // 25% delivered orders get review
      const r = randInt(1, 5);
      review = {
        rating: r,
        reviewText: (r <= 2) ? "Not satisfied with product quality" : "Good product, happy with purchase",
        reviewLength: (r <= 2) ? randInt(10, 60) : randInt(20, 200),
        reviewAt: new Date(new Date(deliveredAt).getTime() + randInt(1, 72) * 3600 * 1000).toISOString()
      };
    }

    // Location and other metadata for analytics
    const geo = sample(cities);
    const channel = sample(channels);
    const paymentMethod = sample(paymentMethods);
    const shippingProvider = sample(shippingProviders);
    const warehouse = sample(warehouses);

    const orderEvent = {
      eventType: "order_created",
      orderId,
      customer: {
        userId: customer.userId,
        segment: customer.segment,
        signupAt: customer.createdAt
      },
      createdAt,
      processedAt,
      shippedAt,
      deliveredAt,
      orderStatus,
      items,
      orderSubtotal: +orderSubtotal.toFixed(2),
      discount,
      shippingFee,
      tax,
grandTotal,
      paymentMethod,
      channel,
      shippingProvider,
      warehouse,
      returnReason,
      geo,
      review,
      meta: {
        source: "demo-generator",
        sequence: i + 1
      }
    };

    try {
      const batch = await producer.createBatch();
      // Add as a single event per order
      if (!batch.tryAdd({ body: orderEvent })) {
        // If it doesn't fit (unlikely for our single-event), send individually
        await producer.sendBatch([ { body: orderEvent } ]);
      } else {
        await producer.sendBatch(batch);
      }

      console.log(`Sent order ${i + 1}/${NUM_ORDERS}: ${orderId} - ${orderEvent.orderStatus} - ${orderEvent.grandTotal}`);
    } catch (err) {
      console.error("Send error:", err);
    }
  }

  await producer.close();
  console.log("All demo orders sent.");
}

main().catch((err) => {
  console.error("Fatal error:", err);
});